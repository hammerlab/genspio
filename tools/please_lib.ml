(**
   A not-really-library to create ["configure.ml"] (or ["please.ml"]) files.

   Add the file in your repo somewhere and [#use] it in your repo.

   {[
     #use "tools/please_lib.ml";;
   ]}


*)

module String = StringLabels
module List = ListLabels
open Printf

let ( // ) = Filename.concat

module Util = struct
  let write_lines p l =
    let o = open_out p in
    List.iter l ~f:(fprintf o "%s\n") ;
    close_out o

  let cmdf fmt =
    ksprintf
      (fun s ->
        match Sys.command s with
        | 0 -> ()
        | other -> ksprintf failwith "Command %S returned %d" s other )
      fmt
end

module Merlin = struct
  let lines ?(pkg= []) ?(s= []) () =
    List.map s ~f:(sprintf "S %s") @ List.map pkg ~f:(sprintf "PKG %s")
end

module Jbuilder = struct
  let jbuild l = [";; Generated by `please_lib.ml`"; "(jbuild_version 1)"] @ l

  let executable ?(ppx= []) ?(modules= []) ?(single_module= false) ~libraries
      name =
    sprintf "(executable ((name %s) %s (libraries (%s))%s))" name
      ( if ppx = [] then ""
      else sprintf "(preprocess (pps (%s)))" (String.concat ~sep:" " ppx) )
      (String.concat libraries ~sep:" ")
      ( match (single_module, modules) with
      | true, [] -> sprintf "(modules (%s))" name
      | true, _ ->
          failwith "Cannot call `executable` with ~single_module and ~modules"
      | false, [] -> ""
      | false, more -> sprintf "(modules (%s))" (String.concat " " more) )

  let rule ~targets ?(deps= []) actions =
    sprintf "(rule ((targets (%s))(deps (%s))(action (progn\n%s))))"
      (String.concat ~sep:" " targets)
      (String.concat ~sep:" " deps)
      (String.concat ~sep:"\n" actions)

  let with_stdout_to path l =
    sprintf "(with-stdout-to %S (progn %s))" path (String.concat ~sep:"\n  " l)

  let progn l = sprintf "(progn %s)" (String.concat ~sep:"\n" l)

  let echo s = sprintf "(echo %S)" s

  let write_file path content = sprintf "(write-file %S %S)" path content

  let run l =
    sprintf "(run %s)" (List.map ~f:(sprintf "%S") l |> String.concat ~sep:" ")

  let install ?(section= "bin") ~package ?(files= []) () =
    sprintf
      "(install ((section %s)\n\
       \          (package %s)\n\
       \         (files (\n\
       %s\n\
       ))))"
      section package
      ( List.map files ~f:(function `As (a, b) -> sprintf "     (%s as %s)" a b )
      |> String.concat ~sep:"\n" )

  let lib ?(deps= []) ?(internal= false) name =
    sprintf "(library ((name %s) %s (libraries (%s)) ))" name
      ( if internal then ""
      else
        sprintf "(public_name %s)"
          (String.map name ~f:(function '_' -> '-' | c -> c)) )
      (String.concat deps ~sep:" ")
end

module Opam = struct
  type qualifier =
    [`Build | `Version of [`GT] * string | `And of qualifier * qualifier]

  let qualifier_to_string q =
    let rec go = function
      | `And (a, b) -> sprintf "%s & %s" (go a) (go b)
      | `Build -> "build"
      | `Version (`GT, s) -> sprintf ">= %S" s
    in
    sprintf "{%s}" (go q)

  let dep ?qualify ?(build= false) n =
    sprintf "%S%s" n
      ( match (qualify, build) with
      | None, false -> ""
      | None, true -> " " ^ qualifier_to_string `Build
      | Some q, false -> " " ^ qualifier_to_string q
      | Some q, true -> " " ^ qualifier_to_string (`And (`Build, q)) )

  let obvious_deps = [dep "jbuilder" ~build:true; dep "ocamlfind" ~build:true]

  let make ?(opam_version= "1.2") ~maintainer ?authors ?(deps= obvious_deps)
      ~homepage ?bug_reports ?dev_repo ?(license= "ISC") ?version
      ?(ocaml_min_version= "4.03.0") ?(configure_script= "please.mlt") name =
    let string k v = sprintf "%s: %S" k v in
    let opt_default o d = match o with None -> d | Some s -> s in
    let opt_f f k v = match v with None -> [] | Some s -> [f k s] in
    (let opt_string k v = opt_f string k v in
     [ sprintf "# This Opam file was auto-generated, see the `%s` script."
         configure_script
     ; string "opam-version" opam_version
     ; string "maintainer" maintainer
     ; (match authors with None -> [maintainer] | Some l -> l)
       |> List.map ~f:(sprintf "%S")
       |> String.concat ~sep:"\n  "
       |> sprintf "authors: [\n  %s\n]"
     ; string "homepage" homepage
     ; string "bug-reports" (opt_default bug_reports (homepage // "issues"))
     ; string "dev-repo" (opt_default dev_repo (homepage ^ ".git"))
     ; string "license" license ]
     @ opt_string "version" version)
    @ [ sprintf "available: [ ocaml-version >= %S ]" ocaml_min_version
      ; sprintf
          "build: [\n\
           \  [\"ocaml\" %S \"configure\"]\n\
           \  [\"jbuilder\" \"build\" \"-p\" %S \"-j\" jobs ]\n\
           ]"
          configure_script name
      ; sprintf "depends: [\n%s\n]"
          (List.map ~f:(sprintf "  %s") deps |> String.concat ~sep:"\n") ]
end

module File = struct
  type t = {path: string; content: string list; no_clean: bool}

  let make ?(no_clean= false) path content = {path; content; no_clean}

  let file = make

  let repo_file = make ~no_clean:true
end

module Main = struct
  let make ?(command= "ocaml " ^ Sys.argv.(0)) ~files ?(argv= Sys.argv)
      ?(more_commands= []) () =
    let usage () =
      eprintf "usage: %s {clean,configure%s}\n%!" command
        ( List.map more_commands ~f:(fun (k, _) -> sprintf ",%s" k)
        |> String.concat ~sep:"" )
    in
    match argv.(1) with
    | "clean" ->
        List.iter files ~f:(function
          | {File.no_clean= false; path; _} ->
              Util.cmdf "rm -f %s" (Filename.quote path)
          | _ -> () )
    | "configure" ->
        List.iter files ~f:(fun {File.path; content} ->
            Util.cmdf "mkdir -p %s" Filename.(dirname path |> quote) ;
            Util.write_lines path content ) ;
        ()
    | other -> (
      match List.find more_commands ~f:(fun (k, v) -> k = other) with
      | _, f -> f ()
      | exception _ ->
          eprintf "Cannot understand command: %S\n%!" other ;
          usage () ;
          exit 1 )
    | exception _ ->
        eprintf "Missing command\n" ;
        usage () ;
        exit 1
end
