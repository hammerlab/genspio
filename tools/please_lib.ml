(**
   A not-really-library to create ["configure.ml"] (or ["please.ml"]) files.

   Add the file in your repo somewhere and [#use] it in your repo.

   {[
     #use "tools/please_lib.ml";;
   ]}


*)


module String = StringLabels
module List = ListLabels
open Printf
let (//) = Filename.concat
module Util = struct
  let write_lines p l =
    let o = open_out p in
    List.iter l ~f:(fprintf o "%s\n");
    close_out o
  let cmdf fmt =
    ksprintf (fun s ->
        match Sys.command s with
        | 0 -> ()
        | other -> ksprintf failwith "Command %S returned %d" s other) fmt
end

module Merlin = struct
  let lines ?(pkg = []) ?(s = []) () =
    List.map s ~f:(sprintf "S %s")
    @ List.map pkg ~f:(sprintf "PKG %s")
end

module Jbuilder = struct

  let jbuild l = [
    ";; Generated by `please.ml`";
    "(jbuild_version 1)";
  ] @ l

  let executable ?(ppx = []) ?(single_module = false) ~libraries name =
    sprintf "(executable ((name %s) %s (libraries (%s))%s))"
      name
      (if ppx = [] then "" else
         sprintf "(preprocess (pps (%s)))"
           (String.concat ~sep:" " ppx))
      (String.concat libraries ~sep:" ")
      (if single_module then sprintf "(modules %s)" name else "")

  let rule ~targets ?(deps = []) actions =
    sprintf "(rule (\
             (targets (%s))\
             (deps (%s))\
             (action (progn\n%s))\
             ))"
      (String.concat ~sep:" " targets)
      (String.concat ~sep:" " deps)
      (String.concat ~sep:"\n" actions)

  let with_stdout_to path l =
    sprintf "(with-stdout-to %S (progn %s))" path (String.concat ~sep:"\n  " l)

  let progn l = sprintf "(progn %s)" (String.concat ~sep:"\n" l)

  let echo s = sprintf "(echo %S)" s

  let write_file path content =
    sprintf "(write-file %S %S)" path content

  let run l =
    sprintf "(run %s)" (List.map ~f:(sprintf "%S") l |> String.concat ~sep:" ")

  let install ?(section = "bin") ~package ?(files = []) () =
    sprintf "(install ((section %s)\n\
            \          (package %s)\n\
            \         (files (\n%s\n))))"
      section package
      (List.map files ~f:(function
         | `As (a, b) -> sprintf "     (%s as %s)" a b)
       |> String.concat ~sep:"\n")

  let lib ?(deps = []) ?(internal = false) name =
    sprintf
      "(library ((name %s) %s (libraries (%s)) ))"
      name
      (if internal then ""
       else
         sprintf "(public_name %s)"
           (String.map name ~f:(function '_' -> '-' | c -> c)))
      (String.concat deps ~sep:" ")

end

module Opam = struct

  let dep ?(build = false) n =
    sprintf "%S%s" n (if build then " {build}" else "")

  let obvious_deps = [
    dep "jbuilder" ~build:true;
    dep "ocamlfind" ~build:true;
  ]

  let make
      ?(opam_version = "1.2")
      ~maintainer
      ?authors
      ?(deps = obvious_deps)
      ~homepage
      ?bug_reports
      ?dev_repo
      ?(license = "ISC")
      ?version
      ?(ocaml_min_version = "4.03.0")
      ?(configure_script = "please.ml")
      name =
    let string k v = sprintf "%s: %S" k v in
    let opt_default o d = match o with None -> d | Some s -> s in
    let opt_f f k v = match v with None -> [] | Some s -> [f k s] in
    let opt_string k v = opt_f string k v in
    [
      sprintf "# This Opam file was auto-generated, see the `%s` script."
        configure_script;
      string "opam-version" opam_version;
      string "maintainer" maintainer;
      begin
        (match authors with | None -> [maintainer] | Some l -> l)
        |> List.map ~f:(sprintf "%S")
        |> String.concat ~sep:"\n  "
        |> sprintf "authors: [\n  %s\n]"
      end;
      string "homepage" homepage;
      string "bug-reports" (opt_default bug_reports (homepage // "issues"));
      string "dev-repo" (opt_default dev_repo (homepage ^ ".git"));
      string "license" license;
    ]
    @ opt_string "version" version;
    @ [
      sprintf "available: [ ocaml-version >= %S ]" ocaml_min_version;
      sprintf "build: [\n\
              \  [\"ocaml\" %S \"configure\"]\n\
              \  [\"jbuilder\" \"build\" \"--only\" %S \"--root\" \
               \".\" \"-j\" jobs \"@install\"]\n\
               ]"
        configure_script name;
      sprintf "depends: [\n%s\n]"
        (List.map ~f:(sprintf "  %s") deps |> String.concat ~sep:"\n")
    ]



end





module File = struct
  type t = {
    path : string;
    content : string list;
    no_clean: bool;
  }
  let make ?(no_clean = false) path content = {path; content; no_clean}
  let file = make
  let repo_file = make ~no_clean:true
end


module Main = struct

  let make
      ?(command = "ocaml " ^ Sys.argv.(0))
      ~files
      ?(argv = Sys.argv)
      ?(more_commands = [])
      () =
    let usage () =
      eprintf "usage: %s {clean,configure%s}\n%!" command
        (List.map more_commands ~f:(fun (k,_) -> sprintf ",%s" k)
         |> String.concat ~sep:"")in
    begin match argv.(1) with
    | "clean" ->
      List.iter files ~f:begin function
      | {File. no_clean = false; path; _} ->
        Util.cmdf "rm -f %s" (Filename.quote path)
      | _ -> ()
      end
    | "configure" ->
      List.iter files ~f:(fun {File. path ; content} ->
          Util.cmdf "mkdir -p %s" Filename.(dirname path |> quote);
          Util.write_lines path content;
        );
      ()
    | other ->
      begin match List.find more_commands ~f:(fun (k, v) -> k = other) with
      | (_, f) -> f ()
      | exception _ ->
        eprintf "Cannot understand command: %S\n%!" other;
        usage ();
        exit 1
      end
    | exception _ ->
      eprintf "Missing command\n";
      usage ();
      exit 1
    end


end

